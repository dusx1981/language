# 从生命周期角度剖析 `slow_add` 和 `@cache_decorator` 的关系

---

## 1. 定义阶段

代码：

```python
@cache_decorator
def slow_add(x, y):
    time.sleep(1)
    return x + y
```

等价于：

```python
def slow_add(x, y):
    time.sleep(1)
    return x + y

slow_add = cache_decorator(slow_add)
```

此时：

1. 原始的 `slow_add`（我们称它为 **slow\_add 原函数**）是一个普通函数对象。
2. 调用 `cache_decorator(slow_add 原函数)`：

   * `cache = {}` 被创建（属于 `cache_decorator` 的局部变量）。
   * 定义了内部函数 `wrapper(*args)`，它引用了 `cache` 和 `func`。
   * `cache_decorator` 返回 `wrapper`。
3. 赋值 `slow_add = wrapper`。

👉 现在，**全局命名空间中的 `slow_add` 指向的是 `wrapper`**，而不是原始函数。

---

## 2. 运行阶段

调用 `slow_add(1, 2)` 实际就是调用 `wrapper(1, 2)`：

* `wrapper` 在其闭包环境里，持有：

  * `func` → 指向原始的 `slow_add 原函数`
  * `cache` → 缓存字典
* `wrapper` 会检查 `cache`，决定是否调用 `func`。

---

## 3. 生命周期分析

### （1）`cache_decorator` 的生命周期

* **进入时**：创建了 `cache`，创建了 `wrapper`。
* **退出时**：按理说 `cache` 应该随局部变量销毁。
* **但实际不会销毁**：因为 `wrapper.__closure__` 中持有 `cache` 的引用，所以它“逃逸”出了 `cache_decorator` 的作用域。
* 生命周期：**与 `wrapper`（即装饰后的 `slow_add`）的生命周期绑定**。

---

### （2）原始 `slow_add` 的生命周期

* 定义在全局命名空间。
* 被 `cache_decorator` 捕获为 `func`。
* 即使全局变量 `slow_add` 已经被替换为 `wrapper`，**原始 `slow_add` 仍然存活**，因为 `wrapper.__closure__` 持有它。
* 生命周期：**与 `wrapper` 绑定**，只有当 `wrapper` 被销毁时，`func` 才可能被垃圾回收。

---

### （3）装饰后的 `slow_add`（其实是 `wrapper`）的生命周期

* 装饰后，`slow_add` 指向 `wrapper`。
* `wrapper` 的存在使得：

  * `cache` 持续存活。
  * `func`（原始 `slow_add`）持续存活。
* 生命周期：

  * 只要全局作用域中 `slow_add` 还存在，或者有其他变量引用 `slow_add`，`wrapper` 就不会被回收。
  * 只有当所有对 `wrapper` 的引用都消失时，Python GC 才会销毁它，进而释放 `cache` 和 `func`。

---

## 4. 关系图示

```
全局命名空间
    slow_add ──────────▶ wrapper 函数对象
                             │
                             ├── closure ───▶ cache = {}
                             │
                             └── closure ───▶ func (原 slow_add)
```

生命周期依赖关系：

* **wrapper 的生命周期 → 决定 cache 与原 slow\_add 的生命周期**。
* **cache\_decorator 函数体结束 ≠ cache 销毁**，因为 cache 已经进入 closure。
* **原 slow\_add 不会被丢弃**，因为 wrapper 在 closure 中持有它。

---

## 5. 结论

| 对象                             | 生命周期             | 为什么不会提前销毁                  |
| ------------------------------ | ---------------- | -------------------------- |
| `cache`                        | 与 `wrapper` 同生共死 | 被捕获进 `wrapper.__closure__` |
| 原始 `slow_add`                  | 与 `wrapper` 同生共死 | 被捕获进 `wrapper.__closure__` |
| 装饰后的 `slow_add`（其实是 `wrapper`） | 与全局变量/引用同生共死     | 只要有引用，就不会被回收               |

所以，**缓存不会丢失**，除非你手动删除所有对 `slow_add` 的引用，例如 `del slow_add`，并且没有别的变量持有它。