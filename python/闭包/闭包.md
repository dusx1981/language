# 深入理解 Python 闭包

---

## 1. 设计思想

闭包的核心思想是：**函数 + 环境**。

* **函数是第一等对象**
  在 Python 中，函数和整数、字符串一样，可以赋值给变量、作为参数传递、作为返回值。这是闭包成立的基础。

* **环境是状态的封装**
  一个函数不仅包含逻辑代码，还可以“记住”它定义时的上下文变量（外部函数的局部变量）。
  这让函数成为一个 **有状态的函数对象**。

**类比 OOP**：

* OOP：把 **数据（属性）+ 行为（方法）** 绑定在对象实例中
* 闭包：把 **数据（自由变量）+ 行为（内部函数逻辑）** 绑定在函数对象中

闭包是一种轻量级的、优雅的 **状态封装机制**。

---

## 2. 实现原理

闭包的形成条件：

1. **嵌套函数**：一个函数内部定义了另一个函数。
2. **自由变量引用**：内部函数引用了外部函数的局部变量。
3. **返回内部函数**：外部函数返回内部函数对象，而不是调用结果。

在 Python 中，闭包依赖于 **`__closure__`** 属性：

* **`__closure__`**：闭包函数对象的属性，保存了被捕获变量的 **cell 对象** 元组。
* **cell 对象**：保存自由变量的值。属性 `cell_contents` 存储当前值。

执行流程：

1. 调用外部函数时，Python 会建立一个新的局部作用域。
2. 内部函数定义时，Python 捕获它引用的外部变量，生成 cell。
3. 外部函数返回后，局部作用域本应销毁，但由于 cell 被内部函数持有，变量得以存活。
4. 当闭包函数被调用时，就能访问并修改这些自由变量。

---

## 3. 举例说明

### 例子 1：计数器

```python
def make_counter():
    count = 0  # 外部函数变量 -> 自由变量

    def counter():
        nonlocal count
        count += 1
        return count

    return counter

counter_a = make_counter()
counter_b = make_counter()

print(counter_a())  # 1
print(counter_a())  # 2
print(counter_b())  # 1 (独立实例)
print(counter_a())  # 3

# 查看闭包内容
print(counter_a.__closure__[0].cell_contents)  # 3
```

`counter_a` 和 `counter_b` 拥有各自独立的 `count`，因为它们捕获了不同的 cell。

---

### 例子 2：函数工厂

```python
def power_factory(exponent):
    def power(base):
        return base ** exponent
    return power

square = power_factory(2)
cube = power_factory(3)

print(square(5))  # 25
print(cube(5))    # 125
```

闭包可以根据外部参数，生成 **定制化函数**。

---

### 例子 3：循环中的陷阱

```python
# 错误示范
def create_functions():
    funcs = []
    for i in range(3):
        def func():
            return i
        funcs.append(func)
    return funcs

f1, f2, f3 = create_functions()
print(f1())  # 2
print(f2())  # 2
print(f3())  # 2
```

**原因**：所有函数捕获的都是同一个 `i`，循环结束时 `i=2`。

解决方案：

```python
# 方法 1：默认参数冻结值
def create_functions_correct():
    funcs = []
    for i in range(3):
        def func(i=i):
            return i
        funcs.append(func)
    return funcs

# 方法 2：再包一层
def create_functions_correct2():
    funcs = []
    for i in range(3):
        def outer(x):
            def inner():
                return x
            return inner
        funcs.append(outer(i))
    return funcs
```

---

## 4. 总结

| 特性       | 说明                                                         |
| -------- | ---------------------------------------------------------- |
| **设计思想** | 函数即对象 + 环境封装；把逻辑与状态绑定在一起                                   |
| **实现原理** | `__closure__` 属性存储自由变量 cell；cell 延长变量生命周期                  |
| **价值**   | 1. 封装状态（如计数器）<br>2. 定制函数（工厂模式）<br>3. 实现装饰器（缓存/日志/权限控制）     |
| **注意事项** | 1. 小心循环变量绑定陷阱（late binding）<br>2. 需理解 `nonlocal` 修改外部变量的用法 |

---

闭包是 Python 装饰器、函数式编程模式的基础，理解它能帮助我们写出更简洁、优雅的代码。
